namespace Redpoint.Uet.BuildPipeline.Executors.Jenkins
{
    using Microsoft.Extensions.Logging;
    using Redpoint.Uet.BuildPipeline.Executors;
    using Redpoint.Uet.BuildPipeline.Executors.BuildServer;
    using System;
    using System.Globalization;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Net.Http.Json;
    using System.Text;
    using System.Threading.Tasks;
    using System.Web;
    using System.Xml;

    public class JenkinsBuildExecutor : BuildServerBuildExecutor
    {
        private readonly ILogger<JenkinsBuildExecutor> _logger;
        private static readonly HttpClient _httpClient = new();

        public JenkinsBuildExecutor(
            IServiceProvider serviceProvider,
            ILogger<JenkinsBuildExecutor> logger,
            string buildServerOutputFilePath) : base(
                serviceProvider,
                buildServerOutputFilePath)
        {
            _logger = logger;

            string? controllerUri = Environment.GetEnvironmentVariable("UET_JENKINS_CONTROLLER_URI");
            if (string.IsNullOrWhiteSpace(controllerUri))
            {
                throw new InvalidOperationException("Jenkins controller URI is not specified, please specify using UET_JENKINS_CONTROLLER_URI environment variable.");
            }
            _httpClient.BaseAddress = new Uri(controllerUri);

            string? authenticationToken = Environment.GetEnvironmentVariable("UET_JENKINS_AUTH");
            if (string.IsNullOrWhiteSpace(authenticationToken))
            {
                throw new InvalidOperationException("Jenkins authorization token is not specified, please specify using UET_JENKINS_AUTH environment variable, format is: your-user-name:apiToken");
            }
            _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", Convert.ToBase64String(Encoding.ASCII.GetBytes(authenticationToken)));
        }

        public override string DiscoverPipelineId()
        {
            // TODO: This is not defined when executing locally, investigate consequence and implement alternative if needed.
            return Environment.GetEnvironmentVariable("BUILD_TAG") ?? string.Empty;
        }

        protected override async Task EmitBuildServerSpecificFileAsync(BuildSpecification buildSpecification, BuildServerPipeline buildServerPipeline, string buildServerOutputFilePath)
        {
            ArgumentNullException.ThrowIfNull(buildServerPipeline);

            foreach (var stage in buildServerPipeline.Stages)
            {
                _logger.LogInformation($"Creating and executing Jenkins jobs for stage '{stage}'");

                var sourceJobsThisStage = buildServerPipeline.Jobs.Where(x => x.Value.Stage == stage).ToDictionary();
                var jobs = new Dictionary<string, JenkinsJob>();
                foreach (var sourceJob in sourceJobsThisStage)
                {
                    var jobName = sourceJob.Key;
                    var jobData = sourceJob.Value;

                    // TODO: Check if job exist. Re-use it?

                    // Job config data.
                    using var stringWriter = new StringWriter();
                    using (var xmlWriter = XmlWriter.Create(stringWriter, new XmlWriterSettings
                    {
                        OmitXmlDeclaration = true,
                        ConformanceLevel = ConformanceLevel.Fragment,
                    }))
                    {
                        xmlWriter.WriteStartElement("project");

                        xmlWriter.WriteStartElement("description");
                        xmlWriter.WriteString("This job was generated by UET.");
                        xmlWriter.WriteEndElement(); // description

                        xmlWriter.WriteStartElement("scm");
                        xmlWriter.WriteAttributeString("class", "hudson.scm.NullSCM");
                        xmlWriter.WriteEndElement(); // scm

                        var nodeLabel = string.Empty;
                        if (jobData.Agent.Platform == BuildServerJobPlatform.Windows)
                        {
                            nodeLabel = "buildgraph-windows";
                        }
                        else if (jobData.Agent.Platform == BuildServerJobPlatform.Mac)
                        {
                            nodeLabel = "buildgraph-mac";
                        }
                        else if (jobData.Agent.Platform == BuildServerJobPlatform.Meta)
                        {
                            // Don't emit this job.
                            continue;
                        }
                        else
                        {
                            throw new InvalidOperationException("Unsupported platform in Jenkins generation!");
                        }

                        xmlWriter.WriteStartElement("assignedNode");
                        xmlWriter.WriteString(nodeLabel);
                        xmlWriter.WriteEndElement(); // assignedNode

                        var buildCommandString = string.Empty;
                        foreach (var kv in jobData.EnvironmentVariables)
                        {
                            buildCommandString += $"$env:{kv.Key}=\'{kv.Value}\'\n";
                        }
                        buildCommandString += jobData.Script("jenkins");

                        xmlWriter.WriteStartElement("builders");
                        xmlWriter.WriteStartElement("hudson.plugins.powershell.PowerShell");
                        xmlWriter.WriteAttributeString("plugin", "powershell@2.2");
                        xmlWriter.WriteStartElement("command");
                        xmlWriter.WriteString(buildCommandString);
                        xmlWriter.WriteEndElement(); // command
                        xmlWriter.WriteStartElement("stopOnError");
                        xmlWriter.WriteString("true");
                        xmlWriter.WriteEndElement(); // stopOnError
                        xmlWriter.WriteEndElement(); // PowerShell
                        xmlWriter.WriteEndElement(); // builders

                        xmlWriter.WriteEndElement(); // project
                    }

                    // Create job.
                    var query = HttpUtility.ParseQueryString(string.Empty);
                    query["name"] = jobName;
                    var uriBuilder = new UriBuilder(_httpClient.BaseAddress + "createItem")
                    {
                        Query = query.ToString()
                    };

                    using StringContent xmlContent = new(stringWriter.ToString(), Encoding.UTF8, "application/xml");

                    using var createJobResponse = await _httpClient.PostAsync(uriBuilder.Uri, xmlContent).ConfigureAwait(false);
                    if (!createJobResponse.IsSuccessStatusCode)
                    {
                        var errorMsg = $"Could not create Jenkins job '{jobName}'.";
                        _logger.LogError(errorMsg);
                        throw new InvalidOperationException(errorMsg);
                    }
                    jobs.Add(jobName, new JenkinsJob());

                    // Submit to build queue.
                    uriBuilder = new UriBuilder(_httpClient.BaseAddress + $"job/{jobName}/build");
                    using var buildResponse = await _httpClient.PostAsync(uriBuilder.Uri, null).ConfigureAwait(false);
                    if (!buildResponse.IsSuccessStatusCode)
                    {
                        var errorMsg = $"Could not enqueue Jenkins job '{jobName}'.";
                        _logger.LogError(errorMsg);
                        throw new InvalidOperationException(errorMsg);
                    }
                    jobs[jobName].QueueUri = buildResponse.Headers.Location;
                    jobs[jobName].Status = JenkinsJobStatus.Queued;
                }

                while (jobs.Any(job => job.Value.Status == JenkinsJobStatus.Queued || job.Value.Status == JenkinsJobStatus.Executing))
                {
                    // Poll build queue for jobs that are starting execution.
                    foreach (var job in jobs.Where(job => job.Value.Status == JenkinsJobStatus.Queued))
                    {
                        var uriBuilder = new UriBuilder(job.Value.QueueUri + "api/json");
                        using var response = await _httpClient.GetAsync(uriBuilder.Uri).ConfigureAwait(false);
                        response.EnsureSuccessStatusCode();
                        var queueResponse = await response.Content.ReadFromJsonAsync(JenkinsJsonSourceGenerationContext.Default.JenkinsQueueItem).ConfigureAwait(false);
                        ArgumentNullException.ThrowIfNull(queueResponse);

                        if (queueResponse.Cancelled ?? false)
                        {
                            var errorMsg = $"Queued job '{job.Key}' was cancelled.";
                            _logger.LogError(errorMsg);
                            throw new InvalidOperationException(errorMsg);
                        }

                        if (queueResponse.Executable != null)
                        {
                            job.Value.ExecutionUri = new Uri(queueResponse.Executable.Url);
                            job.Value.Status = JenkinsJobStatus.Executing;
                        }
                    }

                    // Poll executing builds for progress.
                    foreach (var job in jobs.Where(job => job.Value.Status == JenkinsJobStatus.Executing))
                    {
                        var query = HttpUtility.ParseQueryString(string.Empty);
                        query["start"] = job.Value.ExecutionLogByteOffset.ToString(CultureInfo.InvariantCulture);
                        var uriBuilder = new UriBuilder(job.Value.ExecutionUri + "logText/progressiveText")
                        {
                            Query = query.ToString()
                        };
                        using var response = await _httpClient.GetAsync(uriBuilder.Uri).ConfigureAwait(false);
                        response.EnsureSuccessStatusCode();

                        // Get offset for the next log query, while at the same time check if we received any new log data.
                        int newByteOffset = int.Parse(response.Headers.GetValues("X-Text-Size").First(), CultureInfo.InvariantCulture);
                        if (newByteOffset != job.Value.ExecutionLogByteOffset)
                        {
                            job.Value.ExecutionLogByteOffset = newByteOffset;

                            var newLogText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                            _logger.LogInformation(newLogText); // TODO: Make this print completed lines instead of arbitrary amount of text?
                        }

                        // Check if build is still in progress, header will disappear when build is complete.
                        bool buildStillInProgress = response.Headers.TryGetValues("X-More-Data", out var values) && bool.Parse(values.FirstOrDefault() ?? bool.FalseString);
                        if (!buildStillInProgress)
                        {
                            // TODO: Implement: Did build fail or complete successfully?
                            job.Value.Status = JenkinsJobStatus.Completed;
                        }
                    }

                    // Delay between polling.
                    await Task.Delay(500).ConfigureAwait(false);
                }

                // TODO: Stuff when jobs of this stage have finished?
            }

            // TODO: Stuff when all jobs have finished?
        }
    }
}
