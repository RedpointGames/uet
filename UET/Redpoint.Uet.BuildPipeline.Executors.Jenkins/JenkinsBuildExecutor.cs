namespace Redpoint.Uet.BuildPipeline.Executors.Jenkins
{
    using Microsoft.Extensions.Logging;
    using Redpoint.Concurrency;
    using Redpoint.Uet.BuildPipeline.Executors;
    using Redpoint.Uet.BuildPipeline.Executors.BuildServer;
    using System;
    using System.Globalization;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Net.Http.Json;
    using System.Text;
    using System.Threading.Tasks;
    using System.Web;
    using System.Xml;

    public class JenkinsBuildExecutor : BuildServerBuildExecutor
    {
        private readonly ILogger<JenkinsBuildExecutor> _logger;
        private static readonly HttpClient _httpClient = new();
        private readonly Uri? _gitUri;
        private readonly string _gitBranch;

        public JenkinsBuildExecutor(
            IServiceProvider serviceProvider,
            ILogger<JenkinsBuildExecutor> logger,
            Uri? gitUri,
            string gitBranch) : base(serviceProvider)
        {
            _logger = logger;

            _gitUri = gitUri;
            if (_gitUri == null)
            {
                var gitUriEnv = Environment.GetEnvironmentVariable("GIT_URL");
                if (!string.IsNullOrWhiteSpace(gitUriEnv))
                {
                    Uri.TryCreate(gitUriEnv, UriKind.Absolute, out _gitUri);
                }
            }

            _gitBranch = gitBranch;
            if (string.IsNullOrWhiteSpace(_gitBranch))
            {
                _gitBranch = Environment.GetEnvironmentVariable("GIT_LOCAL_BRANCH") ?? string.Empty;
            }
        }

        public override string DiscoverPipelineId()
        {
            // NOTE: BUILD_TAG gets defined by Jenkins.
            return Environment.GetEnvironmentVariable("BUILD_TAG") ?? string.Empty;
        }

        protected override async Task ExecuteBuildServerSpecificPipelineAsync(BuildSpecification buildSpecification, BuildServerPipeline buildServerPipeline)
        {
            ArgumentNullException.ThrowIfNull(buildServerPipeline);

            var prerequisitesPassed = true;
            if (_gitUri == null)
            {
                _logger.LogError("Jenkins executor requires a valid Git URL. Specify using command-line argument or 'GIT_URL' environment variable.");
                prerequisitesPassed = false;
            }

            if (string.IsNullOrWhiteSpace(_gitBranch))
            {
                _logger.LogError("Jenkins executor requires a valid Git branch. Specify using command-line argument or 'GIT_LOCAL_BRANCH' environment variable.");
                prerequisitesPassed = false;
            }

            string? controllerUri = Environment.GetEnvironmentVariable("UET_JENKINS_CONTROLLER_URL");
            if (string.IsNullOrWhiteSpace(controllerUri))
            {
                _logger.LogError("Jenkins executor requires a valid Jenkins controller URL. Specify using 'UET_JENKINS_CONTROLLER_URL' environment variable.");
                prerequisitesPassed = false;
            }

            string? authenticationToken = Environment.GetEnvironmentVariable("UET_JENKINS_AUTH");
            if (string.IsNullOrWhiteSpace(authenticationToken))
            {
                _logger.LogError("Jenkins executor requires a valid authorization token for Jenkins controller. Specify using 'UET_JENKINS_AUTH' environment variable (example: your-user-name:apiToken)");
                prerequisitesPassed = false;
            }

            if (!prerequisitesPassed)
            {
                throw new BuildPipelineExecutionFailureException("One or more prerequisite checks have failed, fix and try again.");
            }

            _httpClient.BaseAddress = new Uri(controllerUri!);
            _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Basic", Convert.ToBase64String(Encoding.ASCII.GetBytes(authenticationToken!)));

            // Create a UET folder to not clutter the main Jenkins views with generated jobs.
            await CreateOrUpdateJenkinsJob("UET", [], xmlWriter =>
            {
                xmlWriter.WriteStartElement("com.cloudbees.hudson.plugins.folder.Folder");
                xmlWriter.WriteAttributeString("plugin", "cloudbees-folder");
                {
                    xmlWriter.WriteStartElement("description");
                    xmlWriter.WriteString("This folder was generated by UET and contains all generated jobs.");
                    xmlWriter.WriteEndElement(); // description
                    xmlWriter.WriteStartElement("folderViews");
                    xmlWriter.WriteAttributeString("class", "com.cloudbees.hudson.plugins.folder.views.DefaultFolderViewHolder");
                    {
                        xmlWriter.WriteStartElement("views");
                        {
                            xmlWriter.WriteStartElement("hudson.model.AllView");
                            {
                                xmlWriter.WriteStartElement("owner");
                                xmlWriter.WriteAttributeString("class", "com.cloudbees.hudson.plugins.folder.Folder");
                                xmlWriter.WriteAttributeString("reference", "../../../..");
                                xmlWriter.WriteEndElement(); // owner
                                xmlWriter.WriteStartElement("name");
                                xmlWriter.WriteString("All");
                                xmlWriter.WriteEndElement(); // name
                                xmlWriter.WriteStartElement("filterExecutors");
                                xmlWriter.WriteString("false");
                                xmlWriter.WriteEndElement(); // filterExecutors
                                xmlWriter.WriteStartElement("filterQueue");
                                xmlWriter.WriteString("false");
                                xmlWriter.WriteEndElement(); // filterQueue
                                xmlWriter.WriteStartElement("properties");
                                xmlWriter.WriteAttributeString("class", "hudson.model.View$PropertyList");
                                xmlWriter.WriteEndElement(); // properties
                            }
                            xmlWriter.WriteEndElement(); // hudson.model.AllView
                        }
                        xmlWriter.WriteEndElement(); // views
                        xmlWriter.WriteStartElement("tabBar");
                        xmlWriter.WriteAttributeString("class", "hudson.views.DefaultViewsTabBar");
                        xmlWriter.WriteEndElement(); // tabBar
                    }
                    xmlWriter.WriteEndElement(); // folderViews
                    xmlWriter.WriteStartElement("icon");
                    xmlWriter.WriteAttributeString("class", "com.cloudbees.hudson.plugins.folder.icons.StockFolderIcon");
                    xmlWriter.WriteEndElement(); // icon
                }
                xmlWriter.WriteEndElement(); // com.cloudbees.hudson.plugins.folder.Folder
            }).ConfigureAwait(false);

            foreach (var stage in buildServerPipeline.Stages)
            {
                _logger.LogInformation($"Creating and executing Jenkins jobs for stage '{stage}'");

                var sourceJobsThisStage = buildServerPipeline.Jobs.Where(x => x.Value.Stage == stage).ToDictionary();
                var jobs = new Dictionary<string, JenkinsJob>();
                foreach (var sourceJob in sourceJobsThisStage)
                {
                    var jobName = HttpUtility.UrlEncode(sourceJob.Key);
                    var jobData = sourceJob.Value;

                    if (jobData.Agent.Platform == BuildServerJobPlatform.Meta)
                    {
                        // Don't emit this job.
                        continue;
                    }

                    // Create/update job(s) doing the actual work.
                    await CreateOrUpdateJenkinsJob(jobName, ["UET"], xmlWriter =>
                    {
                        xmlWriter.WriteStartElement("project");
                        {
                            xmlWriter.WriteStartElement("description");
                            xmlWriter.WriteString("This job was generated by UET.");
                            xmlWriter.WriteEndElement(); // description

                            xmlWriter.WriteStartElement("scm");
                            xmlWriter.WriteAttributeString("class", "hudson.scm.NullSCM");
                            xmlWriter.WriteEndElement(); // scm

                            xmlWriter.WriteStartElement("assignedNode");
                            var nodeLabel = jobData.Agent.Platform switch
                            {
                                BuildServerJobPlatform.Windows => "buildgraph-windows",
                                BuildServerJobPlatform.Mac => "buildgraph-mac",
                                BuildServerJobPlatform.Meta => throw new NotSupportedException(
                                    "Meta platform not supported."),
                                _ => throw new InvalidOperationException("Unsupported platform in Jenkins generation!")
                            };
                            xmlWriter.WriteString(nodeLabel);
                            xmlWriter.WriteEndElement(); // assignedNode

                            xmlWriter.WriteStartElement("builders");
                            {
                                xmlWriter.WriteStartElement("hudson.plugins.powershell.PowerShell");
                                xmlWriter.WriteAttributeString("plugin", "powershell");
                                {
                                    xmlWriter.WriteStartElement("command");
                                    var buildCommandString = string.Empty;
                                    foreach (var kv in jobData.EnvironmentVariables)
                                    {
                                        buildCommandString += $"$env:{kv.Key}=\'{kv.Value}\'\n";
                                    }
                                    buildCommandString += $"$env:UET_PRIMARY_BUILD_TAG=\'{DiscoverPipelineId()}\'\n";
                                    buildCommandString += $"$env:UET_GIT_URL=\'{_gitUri}\'\n";
                                    buildCommandString += $"$env:UET_GIT_REF=\'{_gitBranch}\'\n";
                                    buildCommandString += jobData.Script("jenkins");
                                    xmlWriter.WriteString(buildCommandString);
                                    xmlWriter.WriteEndElement(); // command
                                    xmlWriter.WriteStartElement("stopOnError");
                                    xmlWriter.WriteString("true");
                                    xmlWriter.WriteEndElement(); // stopOnError
                                }
                                xmlWriter.WriteEndElement(); // PowerShell
                            }
                            xmlWriter.WriteEndElement(); // builders
                        }
                        xmlWriter.WriteEndElement(); // project
                    }).ConfigureAwait(false);

                    jobs.Add(jobName, new JenkinsJob());

                    // Submit to build queue.
                    var uriBuilder = new UriBuilder(_httpClient.BaseAddress + $"job/UET/job/{jobName}/build");
                    using var buildResponse = await _httpClient.PostAsync(uriBuilder.Uri, null).ConfigureAwait(false);
                    if (!buildResponse.IsSuccessStatusCode)
                    {
                        throw new BuildPipelineExecutionFailureException($"Could not enqueue Jenkins job '{jobName}'.");
                    }
                    jobs[jobName].QueueUri = buildResponse.Headers.Location;
                    jobs[jobName].Status = JenkinsJobStatus.Queued;
                }

                while (jobs.Any(job => job.Value.Status == JenkinsJobStatus.Queued || job.Value.Status == JenkinsJobStatus.Executing))
                {
                    // Poll build queue for jobs that are starting execution.
                    foreach (var job in jobs.Where(job => job.Value.Status == JenkinsJobStatus.Queued))
                    {
                        var uriBuilder = new UriBuilder(job.Value.QueueUri + "api/json");
                        using var response = await _httpClient.GetAsync(uriBuilder.Uri).ConfigureAwait(false);
                        response.EnsureSuccessStatusCode();
                        var queueItem = await response.Content.ReadFromJsonAsync(JenkinsJsonSourceGenerationContext.Default.JenkinsQueueItem).ConfigureAwait(false);
                        ArgumentNullException.ThrowIfNull(queueItem);

                        if (queueItem.Cancelled ?? false)
                        {
                            throw new BuildPipelineExecutionFailureException($"Queued job '{job.Key}' was cancelled.");
                        }

                        if (queueItem.Executable != null)
                        {
                            job.Value.ExecutionUri = new Uri(queueItem.Executable.Url);
                            job.Value.Status = JenkinsJobStatus.Executing;
                        }
                    }

                    // Poll executing builds for progress.
                    foreach (var job in jobs.Where(job => job.Value.Status == JenkinsJobStatus.Executing))
                    {
                        var query = HttpUtility.ParseQueryString(string.Empty);
                        query["start"] = job.Value.ExecutionLogByteOffset.ToString(CultureInfo.InvariantCulture);
                        var uriBuilder = new UriBuilder(job.Value.ExecutionUri + "logText/progressiveText")
                        {
                            Query = query.ToString()
                        };
                        using var progressResponse = await _httpClient.GetAsync(uriBuilder.Uri).ConfigureAwait(false);
                        progressResponse.EnsureSuccessStatusCode();

                        // Get offset for the next log query, while at the same time check if we received any new log data.
                        int newByteOffset = int.Parse(progressResponse.Headers.GetValues("X-Text-Size").First(), CultureInfo.InvariantCulture);
                        if (newByteOffset != job.Value.ExecutionLogByteOffset)
                        {
                            job.Value.ExecutionLogByteOffset = newByteOffset;

                            var newLogText = await progressResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                            foreach (var line in newLogText.Split('\n', StringSplitOptions.RemoveEmptyEntries))
                            {
                                var logLevel = line.Contains("FAILURE", StringComparison.OrdinalIgnoreCase) ? LogLevel.Error : LogLevel.Information;
                                _logger.Log(logLevel, $"[Remote: {job.Key}] " + line);
                            }
                        }

                        // Check if build is still in progress, header will disappear when build is complete.
                        var buildStillInProgress = progressResponse.Headers.TryGetValues("X-More-Data", out var values) && bool.Parse(values.FirstOrDefault() ?? bool.FalseString);
                        if (!buildStillInProgress)
                        {
                            uriBuilder = new UriBuilder(job.Value.ExecutionUri + "api/json");
                            using var resultResponse = await _httpClient.GetAsync(uriBuilder.Uri).ConfigureAwait(false);
                            resultResponse.EnsureSuccessStatusCode();
                            var buildInfo = await resultResponse.Content.ReadFromJsonAsync(JenkinsJsonSourceGenerationContext.Default.JenkinsBuildInfo).ConfigureAwait(false);
                            ArgumentNullException.ThrowIfNull(buildInfo);

                            job.Value.Status = buildInfo.Result.Equals("SUCCESS", StringComparison.OrdinalIgnoreCase) ? JenkinsJobStatus.Succeeded : JenkinsJobStatus.Failed;
                        }
                    }

                    // Don't poll too frequently.
                    await Task.Delay(1000).ConfigureAwait(false);
                }

                // Don't bother starting the next stage if a prerequisite job has failed.
                if (jobs.Any(job => job.Value.Status == JenkinsJobStatus.Failed))
                {
                    throw new BuildPipelineExecutionFailureException("A job has failed, aborting build process.");
                }
            }
        }

        private static async Task CreateOrUpdateJenkinsJob(string jobName, string[] parentJobs,
            Action<XmlWriter> writeEvent)
        {
            // Write job config XML.
            await using (new StringWriter().AsAsyncDisposable(out var stringWriter).ConfigureAwait(false))
            {
                var xmlWriterSettings = new XmlWriterSettings
                {
                    OmitXmlDeclaration = true,
                    Indent = true,
                    NewLineOnAttributes = true,
                    ConformanceLevel = ConformanceLevel.Fragment,
                    Async = true,
                };

                await using (XmlWriter.Create(stringWriter, xmlWriterSettings).AsAsyncDisposable(out var xmlWriter)
                                 .ConfigureAwait(false))
                {
                    writeEvent(xmlWriter);
                }

                var parentJobPaths =
                    parentJobs.Aggregate(string.Empty, (current, parentJob) => current + $"job/{parentJob}/");

                var jobPath = $"job/{jobName}/";

                // Create or update Jenkins job depending on whether it exists.
                var uriBuilder = new UriBuilder(_httpClient.BaseAddress + parentJobPaths + jobPath + "api/json");
                using var checkResponse = await _httpClient.GetAsync(uriBuilder.Uri).ConfigureAwait(false);
                if (checkResponse.IsSuccessStatusCode)
                {
                    // Job exists already, update config.
                    uriBuilder = new UriBuilder(_httpClient.BaseAddress + parentJobPaths + jobPath + "config.xml");

                    using StringContent xmlContent = new(stringWriter.ToString(), Encoding.UTF8, "text/xml");

                    using var updateJobResponse =
                        await _httpClient.PostAsync(uriBuilder.Uri, xmlContent).ConfigureAwait(false);
                    if (!updateJobResponse.IsSuccessStatusCode)
                    {
                        throw new BuildPipelineExecutionFailureException($"Could not update Jenkins job '{jobName}'.");
                    }
                }
                else
                {
                    // Create new job.
                    var query = HttpUtility.ParseQueryString(string.Empty);
                    query["name"] = jobName;
                    uriBuilder = new UriBuilder(_httpClient.BaseAddress + parentJobPaths + "createItem")
                    {
                        Query = query.ToString()
                    };

                    using StringContent xmlContent = new(stringWriter.ToString(), Encoding.UTF8, "application/xml");

                    using var createJobResponse =
                        await _httpClient.PostAsync(uriBuilder.Uri, xmlContent).ConfigureAwait(false);
                    if (!createJobResponse.IsSuccessStatusCode)
                    {
                        throw new BuildPipelineExecutionFailureException($"Could not create Jenkins job '{jobName}'.");
                    }
                }
            }
        }
    }
}