namespace UET.Commands.Internal.Tpm
{
    using Microsoft.Extensions.Logging;
    using Redpoint.CommandLine;
    using Redpoint.Tpm;
    using Redpoint.Tpm.Internal;
    using System.CommandLine;
    using System.CommandLine.Invocation;
    using System.Security.Cryptography;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using System.Threading.Tasks;
    using Tpm2Lib;

    internal sealed class TpmCreateAikCommand : ICommandDescriptorProvider<UetGlobalCommandContext>
    {
        public static CommandDescriptor<UetGlobalCommandContext> Descriptor => UetCommandDescriptor.NewBuilder()
            .WithOptions<Options>()
            .WithInstance<TpmCreateAikCommandInstance>()
            .WithRuntimeServices((_, services, _) =>
            {
                services.AddTpm();
            })
            .WithCommand(
                builder =>
                {
                    return new Command("create-aik");
                })
            .Build();

        internal sealed class Options
        {
            public Option<bool> UseService;
            public Option<int> Length;

            public Options()
            {
                UseService = new Option<bool>("--use-service", "Use service.");
                UseService.AddAlias("-s");

                Length = new Option<int>("--length", "Length of generated data to protect.");
                Length.AddAlias("-l");
                Length.SetDefaultValue(32);
            }
        }

        private sealed class TpmCreateAikCommandInstance : ICommandInstance
        {
            private readonly ILogger<TpmCreateAikCommandInstance> _logger;
            private readonly Options _options;
            private readonly ITpmService _tpmService;

            public TpmCreateAikCommandInstance(
                ILogger<TpmCreateAikCommandInstance> logger,
                Options options,
                ITpmService tpmService)
            {
                _logger = logger;
                _options = options;
                _tpmService = tpmService;
            }

            private class TpmAutoFlush : IDisposable
            {
                private readonly Tpm2 _tpm;
                private readonly TpmHandle _handle;

                public TpmAutoFlush(Tpm2 tpm, TpmHandle handle)
                {
                    _tpm = tpm;
                    _handle = handle;
                }

                public void Dispose()
                {
                    _tpm.FlushContext(_handle);
                }
            }

            public async Task<int> ExecuteAsync(ICommandInvocationContext context)
            {
                if (context.ParseResult.GetValueForOption(_options.UseService))
                {
                    return await ExecuteServiceAsync(context);
                }
                else
                {
                    return await ExecuteRawAsync(context);
                }
            }

            private async Task<int> ExecuteServiceAsync(ICommandInvocationContext context)
            {
                var (ekPublicBytes, aikPublicBytes, operationHandles) = await _tpmService.CreateRequestAsync();

                var generatedBytes = RandomNumberGenerator.GetBytes(context.ParseResult.GetValueForOption(_options.Length));
                _logger.LogInformation($"Generated bytes: {Convert.ToHexStringLower(generatedBytes)}");

                var (envelopingKeyBytes, encryptedKey, encryptedData) = _tpmService.Authorize(
                    ekPublicBytes,
                    aikPublicBytes,
                    generatedBytes);

                var decryptedGeneratedBytes = _tpmService.DecryptSecretKey(
                    operationHandles,
                    envelopingKeyBytes,
                    encryptedKey,
                    encryptedData);
                _logger.LogInformation($"Decrypted generated bytes: {Convert.ToHexStringLower(generatedBytes)}");
                return 0;
            }

            private async Task<int> ExecuteRawAsync(ICommandInvocationContext context)
            {
                using Tpm2Device tpmDevice = OperatingSystem.IsWindows() ? new TbsDevice() : new LinuxTpmDevice();
                tpmDevice.Connect();

                using var tpm = new Tpm2(tpmDevice);

                // Set algorithm.
                var alg = TpmAlgId.Sha256;

                // Get EK.
                _logger.LogInformation("Getting EK handle...");
                var ekHandle = new TpmHandle(0x81010001);
                var ekPublicKey = tpm._AllowErrors().ReadPublic(ekHandle, out var ekName, out var ekQName);
                if (!tpm._LastCommandSucceeded())
                {
                    _logger.LogError("Failed to read public EK from TPM!");
                    return 1;
                }

                // Create AIK.
                _logger.LogInformation("Creating AIK...");
                var aikPolicyTree = new PolicyTree(alg);
                var aikPolicyOr = new TpmPolicyOr();
                aikPolicyTree.SetPolicyRoot(aikPolicyOr);
                aikPolicyOr.AddPolicyBranch(new TpmPolicyCommand(TpmCc.ActivateCredential, "Activate"));
                aikPolicyOr.AddPolicyBranch(new TpmPolicyCommand(TpmCc.Certify, "Certify"));
                aikPolicyOr.AddPolicyBranch(new TpmPolicyCommand(TpmCc.CertifyCreation, "CertifyCreation"));
                aikPolicyOr.AddPolicyBranch(new TpmPolicyCommand(TpmCc.Quote, "Quote"));

                var aikPublicKey = new TpmPublic(
                    alg,
                    ObjectAttr.Restricted |
                        ObjectAttr.Sign |
                        ObjectAttr.FixedParent |
                        ObjectAttr.FixedTPM |
                        ObjectAttr.AdminWithPolicy |
                        ObjectAttr.SensitiveDataOrigin,
                    aikPolicyTree.GetPolicyDigest(),
                    new RsaParms(new SymDefObject(), new SchemeRsassa(alg), 2048, 0),
                    new Tpm2bPublicKeyRsa());

                var aikCreateResponse = await tpm.CreatePrimaryAsync(
                    TpmRh.Endorsement,
                    new SensitiveCreate(tpm.GetRandom(TpmHash.DigestSize(alg)), null),
                    aikPublicKey,
                    null,
                    null);

                aikPublicKey = aikCreateResponse.outPublic;
                var aikHandle = aikCreateResponse.handle;
                using var aikHandleAutoFlush = new TpmAutoFlush(tpm, aikHandle);

                {
                    var ekPublicBytes = ekPublicKey.GetTpmRepresentation();
                    var aikPublicBytes = aikPublicKey.GetTpmRepresentation();
                    _logger.LogTrace($"CreateRequestAsync result (EK public bytes size: {ekPublicBytes.Length}, AIK public bytes size: {aikPublicBytes.Length}, AIK name hex: {Convert.ToHexStringLower(aikCreateResponse.outPublic.GetName())})");

                    ekPublicKey = new Marshaller(ekPublicBytes).Get<TpmPublic>();
                    aikPublicKey = new Marshaller(aikPublicBytes).Get<TpmPublic>();
                }

                // Generate bytes.
                var generatedBytes = RandomNumberGenerator.GetBytes(context.ParseResult.GetValueForOption(_options.Length));
                _logger.LogInformation($"Generated bytes: {Convert.ToHexStringLower(generatedBytes)}");

                // Create activation credentials.
                _logger.LogInformation($"Creating activation credentials for AIK (AIK public key name length: {aikPublicKey.GetName().Length})...");
                var envelopingKey = ekPublicKey.CreateActivationCredentials(
                    generatedBytes,
                    aikPublicKey.GetName(),
                    out var encryptedSecret);
                var envelopingKeyBytes = envelopingKey.EnvelopingKeyToBytes(_logger);

                // Create sessions for AIK usage.
                _logger.LogTrace($"Starting auth session for AIK...");
                var aikSession = tpm.StartAuthSessionEx(
                    TpmSe.Policy,
                    alg);
                using var aikSessionAutoFlush = new TpmAutoFlush(tpm, aikSession);
                aikSession.RunPolicy(tpm, aikPolicyTree, "Activate");

                // Determine policy tree for EK usage.
                _logger.LogTrace($"Creating policy tree for EK...");
                var ekPolicyTree = new PolicyTree(ekPublicKey.nameAlg);
                ekPolicyTree.SetPolicyRoot(new TpmPolicySecret(
                    TpmRh.Endorsement,
                    false,
                    0,
                    null,
                    null));

                // Create session for EK usage.
                _logger.LogTrace($"Starting auth session for EK (alg: {ekPublicKey.nameAlg})...");
                var ekSession = tpm.StartAuthSessionEx(
                    TpmSe.Policy,
                    ekPublicKey.nameAlg);
                using var ekSessionAutoFlush = new TpmAutoFlush(tpm, ekSession);
                ekSession.RunPolicy(tpm, ekPolicyTree);

                // Activate the AIK credential.
                _logger.LogInformation($"Activating AIK... (enveloping key bytes size: {envelopingKeyBytes.Length}, encrypted Key: {encryptedSecret.Length})");
                envelopingKey = envelopingKeyBytes.BytesToEnvelopingKey(_logger);
                var recoveredGeneratedBytes = tpm[aikSession, ekSession]
                    .ActivateCredential(
                        aikHandle,
                        ekHandle,
                        envelopingKey,
                        encryptedSecret);

                _logger.LogInformation($"Decrypted generated bytes: {Convert.ToHexStringLower(recoveredGeneratedBytes)}");

                // Export PEM.
                _logger.LogInformation($"EK: {ToPem(ekPublicKey)}");
                _logger.LogInformation($"AIK: {ToPem(aikPublicKey)}");

                _logger.LogInformation($"EK Hash: {ToHash(ekPublicKey)}");
                _logger.LogInformation($"AIK Hash: {ToHash(aikPublicKey)}");

                return 0;
            }

            private static string ToPem(TpmPublic key)
            {
                var rsaParams = (RsaParms)key.parameters;
                var exponent = rsaParams.exponent != 0 ? Globs.HostToNet(rsaParams.exponent) : RsaParms.DefaultExponent;
                var modulus = (key.unique as Tpm2bPublicKeyRsa)!.buffer;

                var publicKey = new RSACryptoServiceProvider();
                publicKey.ImportParameters(new RSAParameters
                {
                    Exponent = exponent,
                    Modulus = modulus,
                });
                return publicKey.ExportRSAPublicKeyPem();
            }

            private static string ToHash(TpmPublic key)
            {
                var rsaParams = (RsaParms)key.parameters;
                var exponent = rsaParams.exponent != 0 ? Globs.HostToNet(rsaParams.exponent) : RsaParms.DefaultExponent;
                var modulus = (key.unique as Tpm2bPublicKeyRsa)!.buffer;

                return Convert.ToHexStringLower(SHA256.HashData(exponent.Concat(modulus).ToArray()));
            }
        }
    }
}
